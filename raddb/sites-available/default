server default {
	namespace = radius
	listen {
		type = Access-Request
		transport = udp
		udp {
			ipaddr = *
			port = 1812
		}
	}

	recv Access-Request {
		python
	}
<<<<<<< Updated upstream

	#
	#  The `unix` module will obtain passwords from `/etc/passwd`
	#  or `/etc/shadow`.  It does this via the system API's, which
	#  are not thread-safe.  We do not recommend using the `unix` module.
	#
#	unix

	#
	#  Read what used to be the `users` file. Since v3, this file
	#  is located in `mods-config/files/authorize`.
	#
	files

	#
	#  Look in an SQL database. The schema of the database is
	#  meant to mirror the `users` file.  For a full description
	#  of the module behavior, please see
	#  https://wiki.freeradius.org/modules/Rlm_sql
	#
	-sql

	#
	#  If you are using /etc/smbpasswd, and are also doing mschap
	#  authentication, the uncomment this line, configure the
	#  module.
	#
#	smbpasswd

	#
	#  The `ldap` module reads passwords and other attributes from
	#  an LDAP database.
	#
	#  For a full description of the module behavior, please see
	#  https://wiki.freeradius.org/modules/Rlm_ldap
	#
	-ldap

	#
	#  Enforce daily limits on time spent logged in. This module
	#  is a variant of the `counter` module.
	#
#	dailycounter

	#
	#  See if the account has expired: check the time in the
	#  `Expiration` attribute and reject if we are past it.
	#  If the account has not expired, set `Session-Timeout`.
	#
	expiration

	#
	#  Look at the `Login-Time` attribute and reject if the user
	#  is not allowed access at the present time. Otherwise,
	#  set `Session-Timeout` to the end of the permitted time span.
	#
	logintime

	#
	#  The `pap` module will set `Auth-Type := PAP` if the
	#  packet contains a `User-Password` attribute.  The module
	#  does this only if the `Auth-Type` attribute has not already
	#  been set.
	#
	#  The `pap` module is also responsible for "normalizing" the
	#  various kinds of "known good" passwords.
	#  e.g. `NT-Password` may come as a 16 byte blob, or as a
	#  32-byte hex string, or as a base-64 encoded string.  The
	#  `pap` module will look for common variations of password
	#  encoding, and convert them all to a normal form.
	#
	#  This module should be listed last, so that the other
	#  modules get a chance to set Auth-Type for themselves.
	#
	pap
}


#
#  ### Receive Status-Server packets
#
#
#  This section is processed when the server receives a `Status-Server`
#  packet.
#
recv Status-Server {
	#
	#  We are still here and responding.
	#
	ok
}



######################################################################
#
#  ## Authentication Sections
#
#  The sub-sections below are called based on the value of the
#  `Auth-Type` attribute, which should have been set by the `recv
#  Access-Request` section, above.
#
#  Since version 4, proxying also happens in this section.  For more
#  information on how proxying has changed in version 4, please see
#  https://wiki.freeradius.org/upgrading/version4/proxy.
#
#  For authentication, you should generally NOT set the `Auth-Type`
#  attribute.  As noted above, the modules will usually figure it what
#  to do, and will do the right thing.  The most common side effect of
#  erroneously setting the `Auth-Type` attribute is that one
#  authentication method will work, but all of the others will not.
#
#  The common reasons to set the `Auth-Type` attribute by hand are
#  to forcibly reject the user (`Auth-Type := Reject`), to or
#  forcibly accept the user (`Auth-Type := Accept`), or for
#  proxying.
#
#  Note that `Auth-Type := Accept` will NOT work with EAP.  The EAP
#  authentication protocol uses a series of handshake messages.  All
#  of the messages must be exchanged correctly in order for EAP
#  authentication to succeed.  Bypassing that process with `Auth-Type
#  := Accept` will just result in the user being rejected.
#
#  Policy configuration should generally go in the `send ...` sections
#  below, after authentication has completed.
#
######################################################################

#
#  ### PAP Authentication
#
#  For users who are using PAP authentication. A back-end database
#  listed in the "recv Access-Request" section MUST supply a "known
#  good" password for the user.  The password can be clear-text, or
#  encrypted via `crypt`, `bcrypt`, or other hashing.
#
authenticate pap {
	pap
}

#
#  ### CHAP Authentication
#
#  For users who are using CHAP authentication. A back-end database
#  listed in the "recv Access-Request" section MUST supply a
#  Password.Cleartext attribute. Encrypted passwords won't work.
#
authenticate chap {
	chap
}

#
#  ### MS-CHAP authentication
#
#  For users who are using MS-CHAP authentication. A back-end
#  database listed in the "recv Access-Request" section MUST supply
#  either a Password.Cleartext attribute, or an NT-Password
#  attribute. Encrypted passwords won't work.
#
authenticate mschap {
	mschap
}

#
#  ### SIP Digest Authentication
#
#  For users who are using SIP Digest authentication.
#
#  The `digest` line in the `recv Access-Request` section should also
#  be uncommented.
#
authenticate digest {
	digest
}

#
#  ## PAM (Pluggable Authentication Modules) Authentication
#
#  Authenticate with PAM (Pluggable Authentication Modules).
#
#  We do not recommend using PAM.  The server has enough functionality
#  that anything that can be done in PAM can be done easier in
#  FreeRADIUS.
#
#authenticate pam {
#	pam
#}

#
#  ### LDAP Authentication
#
#  For users who are using PAP, and when you can't get the "known
#  good" password from LDAP.  The module binds to the LDAP directory
#  as the user, along with the password taken from the User-Password
#  attribute.  The "bind as user" method means that CHAP, MS-CHAP, and
#  EAP won't work, as they do not supply a plain-text password.
#
#  We do NOT recommend using this. LDAP servers are databases, not
#  authentication servers.  It is only here as a last resort for
#  databases such as Active Directory.
#
#  We strongly recommend using `ldap` in the `recv Access-Request`
#  section.  And, ensuring that the account used by FreeRADIUS has
#  read permission on all of the users, groups, and passwords.
#
authenticate ldap {
	-ldap
}

#
#  EAP Authentication
#
#  For EAP-MD5, EAP-MSCHAP, EAP-TLS, EAP-TTLS, EAP-PEAP, EAP-PWD, etc.
#
authenticate eap {
	eap
}


#
#  ### Proxying
#
#  Proxying has changed substantially from v3 to v4.  These changes
#  are complex, but were necessary in order to support new features.
#  The result is that configurations which were impossible in v3 are
#  now trivial in v4.  For example:
#
#  * sending the same packet to multiple destinations, along with retransmissions
#  * sending the same packet to multiple destinations in parallel
#  * trying to proxy, and if it fails, programmatically doing something else
#  * trying to proxy, and if it fails, authenticating the user locally
#    * note that this won't work for EAP.
#
#  For more information, see:
#  https://wiki.freeradius.org/upgrading/version4/proxy.
#

#
#  The following example shows how proxying to three remote servers
#  can be configured.
#
#  The `Auth-Type` attribute would need to be set to
#  `proxy-example.com`.  The home servers MUST be defined in
#  `mods-available/radius`.
#

#authenticate proxy-example.com {
#	#
#	#  Log the request before proxying.
#	#
#	pre_proxy_log
#
#	#
#	#  Send the request to remote RADIUS servers, with
#	#  fail-over from one to the other if there's no response.
#	#
#	redundant {
#		radius1.example.com
#		radius2.example.com
#		radius3.example.com
#	}
#
#	#
#	#  Log the reply after proxying.
#	#
#	post_proxy_log.post-proxy
#}



#
#  ## Send replies to Access-Request packets
#

#
#  ### send Access-Challenge packets
#
#
#  This section is called when sending an Access-Challenge
#  response. It is configured to filter out all attributes that should
#  not be in the packet.
#
send Access-Challenge {
	attr_filter.access_challenge.post-auth
	handled
}

#
#  ### send Access-Accept packets
#
#  Once we know that the user has been authenticated successfully,
#  there are additional things that can be done.
#
send Access-Accept {
	#
	#  If you need to have a State attribute, you can add it
	#  here. e.g. for later CoA-Request with State, and
	#  Service-Type = Authorize-Only.
	#
#	if (!&reply.State) {
#		update reply {
#			&State := "0x%{randstr:16h}"
#		}
#	}

	#
	#  For EAP-TTLS and PEAP, add any cached attributes to the
	#  reply. The "session-state" attributes are automatically
	#  cached when an Access-Challenge is sent, and retrieved
	#  when an `Access-Request` is received.
	#
	#  The `session-state` attributes are deleted after an
	#  `Access-Reject` or `Access-Accept` packet has been sent.
	#
	update {
		&reply += &session-state
	}

	#
	#  For EAP, ensure that the Access-Accept contains a User-Name
	#  attribute.
	#
	eap

	#
	#  Get an address from the IP Pool.
	#
#	sqlippool


	#
	#  Create the CUI value and add the attribute to
	#  Access-Accept. Uncomment the line below if
	#  *returning* the CUI to the NAS.
	#
#	cui

	#
	#  If you want to have a log of authentication replies,
	#  uncomment the following line. This is defined in
	#  `mods-available/detail.log`.
	#
#	reply_log

	#
	#  After authenticating the user, do another SQL query.
	#
	-sql

	#
	#  Instead of sending the query to the SQL server in
	#  real-time, write it into a log file to be picked up and
	#  sent to the database later.
	#
#	sql_log

	#
	#  Uncomment the following if you want to modify the
	#  user's object in LDAP after a successful login.
	#
#	ldap

	#
	#  Calculate the various WiMAX keys. In order for this to
	#  work, you will need to define the WiMAX NAI, usually
	#  via:
	#
#	update request {
#		&WiMAX-MN-NAI = "%{User-Name}"
#	}

	#  If you want various keys to be calculated, you will
	#  need to update the reply with "template" values. The
	#  module will see this, and replace the template values
	#  with the correct ones taken from the cryptographic
	#  calculations, e.g.
	#
#	update reply {
#		&Vendor-Specific.WiMAX.FA-RK-Key = 0x00
#		&Vendor-Specific.WiMAX.MSK = "%{reply.EAP-MSK}"
#	}

	#  You may want to delete the `MS-MPPE-*-Keys` from the
	#  reply, as some WiMAX clients behave badly when those
	#  attributes are included. See the configuration entry
	#  `delete_mppe_keys` in `mods-available/wimax` for
	#  more information.
	#
#	wimax

	#
	#  If there is a client certificate (EAP-TLS, and very
	#  occasionally PEAP and EAP-TTLS), then some attributes
	#  are filled out after the certificate verification has
	#  been performed. These fields MAY be available during
	#  the authentication, or they may be available only in
	#  the appropriate "send" section.
	#
	#  The first set of attributes contains information about
	#  the issuing certificate which is being used. The second
	#  contains information about the client certificate (if
	#  available).
	#
#	update reply {
#		&Reply-Message += "%{session-state.TLS-Cert-Serial}"
#		&Reply-Message += "%{session-state.TLS-Cert-Expiration}"
#		&Reply-Message += "%{session-state.TLS-Cert-Subject}"
#		&Reply-Message += "%{session-state.TLS-Cert-Issuer}"
#		&Reply-Message += "%{session-state.TLS-Cert-Common-Name}"
#		&Reply-Message += "%{session-state.TLS-Cert-Subject-Alt-Name-Email}"
#
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Serial}"
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Expiration}"
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Subject}"
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Issuer}"
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Common-Name}"
#		&Reply-Message += "%{session-state.TLS-Client-Cert-Subject-Alt-Name-Email}"
#	}

	#
	#  Insert the `Class` attribute with a unique value into the
	#  response, which aids matching auth and acct records and
	#  protects against duplicate Acct-Session-Id.
	#
	#  Note: This only works if the NAS has implemented RFC
	#  2865 behaviour for the Class attribute, AND if the NAS
	#  supports long Class attributes. Many older or cheap
	#  NASes only support 16-octet Class attributes.
	#
#	insert_acct_class

	#
	#  MacSEC requires the use of `EAP-Key-Name`. However, we
	#  don't want to send it for all EAP sessions. Therefore, the
	#  EAP modules put required data into the `EAP-Session-Id`
	#  attribute. This attribute is never put into a request or
	#  reply packet.
	#
	#  Uncomment the next few lines to copy the required data
	#  into the EAP-Key-Name attribute.
#
#	if (&reply.EAP-Session-Id) {
#		update reply {
#			&EAP-Key-Name := &reply.EAP-Session-Id
#		}
#	}

	#
	#  Remove `Reply-Message` if the response contains an
	#  `EAP-Message` attribute.  Some NAS equipment will
	#  automatically convert the `Reply-Message` to an "EAP
	#  notification" packet, which will cause end-user machines to
	#  drop the network connection.
	#
	remove_reply_message_if_eap
}

#
#  ### send Access-Reject packets
#
#  This section processes `Access-Reject` packets before they are sent
#  to the NAS.
#
#  The `session-state` list is available while this section is being
#  processed.  But all of the attributes in that list are discarded as
#  soon as the section is finished.
#
send Access-Reject {
	#
	#  Log failed authentications in SQL, too.
	#
	-sql

	#
	#  Filter out attributes that should not be in
	#  Access-Reject packets.
	#
	attr_filter.access_reject

	#
	#  Insert an EAP-Failure message if the request was rejected by
	#  policy, instead of from an authentication failure.
	#
	eap

	#
	#  Remove `Reply-Message` if the response contains an
	#  `EAP-Message` attribute.  Some NAS equipment will
	#  automatically convert the `Reply-Message` to an "EAP
	#  notification" packet, which will cause end-user machines to
	#  drop the network connection.
	#
	remove_reply_message_if_eap

	#
	#  Delay sending the `Access-Reject` packet. This is no
	#  longer automatic as it was in version 3.
	#
	delay_reject
}



######################################################################
#
#  Accounting
#
#
#  This section deals with receiving Accounting requests and
#  sending Accounting responses.
#
######################################################################

#
#  An Accounting-Request packet has been received. Decide which
#  accounting type to use.
#
recv Accounting-Request {
	#
	#  Merge Acct-[Input|Output]-Gigawords and
	#  Acct-[Input-Output]-Octets into a single 64-bit
	#  counter, Acct-[Input|Output]-Octets64.
	#
#	acct_counters64

	#
	#  Session start times are *implied* in RADIUS. The NAS
	#  never sends a "start time". Instead, it sends a start
	#  packet, *possibly* with an Acct-Delay-Time. The server
	#  is supposed to conclude that the start time was
	#  "Acct-Delay-Time" seconds in the past.
	#
	#  The unlang below creates an explicit start time, which
	#  can then be used in other modules. It will be *mostly*
	#  correct. Any errors are due to the 1-second resolution
	#  of RADIUS, and the possibility that the time on the NAS
	#  may be off.
	#
	#  The start time is: NOW - delay - session_length
	#
#	update request {
#		&FreeRADIUS-Acct-Session-Start-Time = "%{expr: %{%{Event-Timestamp}:-%l} - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
#	}

	#
	#  The packet should have a timestamp.  If not, use "now" from the server.
	#
	if (!&Event-Timestamp) {
		update request {
			&Event-Timestamp := "%l"
		}
	}

	#
	#  Ensure that we have a semi-unique identifier for every
	#  request, as many NAS boxes are broken.
	#
	acct_unique

	#
	#  Read the 'acct_users' file.
	#
	files
}

#
#  Version 4 allows for sections specific to Acct-Status-Type.
#
#  Once the `recv Accounting-Request` section is processed, one of the
#  `accounting ... { ... }` sections will be run, based on the
#  value of the `Acct-Status-Type` attribute.
#
#  After the `accounting ... { ... }` section has been run, it will
#  then process the `send Accounting-Response` section
#

#
#  Session start
#
accounting Start {

}

#
#  Session stop
#
accounting Stop {

}

#
#  Session is still alive
#
accounting Alive {

}

#
#  The NAS has just booted up.
#
accounting Accounting-On {

}

#
#  The NAS is about to go down
#
accounting Accounting-Off {

}

#
#  Session failed to do something
#
accounting Failed {

}

#
#  There are many other values for `Acct-Status-Type` such as:
#
#  * Tunnel-Start
#  * Tunnel-Stop
#  * Tunnel-Reject
#  * Tunnel-Link-Start
#  * Tunnel-Link-Stop
#  * Tunnel-Link-Reject
#
#  Some vendors also define their own values, which is a very bad idea.
#

#
#  Send Accounting-Response.
#
#  Log the accounting data before replying. If logging fails then
#  the reply will not be sent, which means the NAS will send the
#  request again.
#
send Accounting-Response {
	#
	#  Add the CUI attribute from the corresponding
	#  Access-Accept to the Accounting-Response.
	#
	#  Use it only if your NAS boxes do not support CUI
	#  themselves.
	#
#	cui

	#
	#  Create a 'detail'ed log of the packets. Note that
	#  accounting requests which are proxied are also logged
	#  in the detail file.
	#
	detail

	#
	#  Update counters for daily usage calculations.
	#
#	daily

	#
	#  Update the wtmp file.
	#
	#  If you don't use "radlast", you can delete this line.
	#
	unix

	#
	#  For Simultaneous-Use tracking.
	#
	#  Due to packet losses in the network, the data here may
	#  be incorrect. There is little we can do about it.
	#
#	radutmp
#	sradutmp

	#
	#  Refresh leases when we see a start or alive. Return an address to
	#  the IP Pool when we see a stop record.
	#
	#  Ensure that &control.IP-Pool.Name is set to determine which
	#  pool of IPs are used.
	#
#	sqlippool

	#
	#  Log traffic to an SQL database.
	#
	#  See "Accounting Queries" in `mods-available/sql`.
	#
	-sql

	#
	#  If you receive stop packets with zero session length,
	#  they will NOT be logged in the database. The SQL
	#  module will print a message (only in debugging mode),
	#  and will return "noop".
	#
	#  You can ignore these packets by uncommenting the
	#  following three lines. Otherwise, the server will not
	#  respond to the accounting request, and the NAS will
	#  retransmit.
	#
#	if (noop) {
#		ok
#	}

	#
	#  Instead of sending the query to the SQL server in
	#  real-time, write it into a log file to be picked up and
	#  sent to the database later.
	#
#	sql_log

	#
	#  Cisco VoIP specific bulk accounting.
	#
#	pgsql-voip

	#
	#  Filter attributes from the accounting response.
	#
	attr_filter.accounting_response
}
=======
>>>>>>> Stashed changes
}
