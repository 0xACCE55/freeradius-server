#  $Id$
#
# FreeRADIUS rlm_sqlippool SQL Queries for the PostgreSQL Dialect

 ## This series of queries allocates an IP address
 allocate-clear = "UPDATE ${ippool_table} \
  SET nasipaddress = '', pool_key = 0, callingstationid = '', \
  expiry_time = 'now'::timestamp(0) - '1 second'::interval \
  WHERE pool_key = '${pool-key}'"

 ## The ORDER BY clause of this query tries to allocate the same IP-address
 ## which user had last session...
 allocate-find = "SELECT framedipaddress FROM ${ippool_table} \
  WHERE pool_name = '%{control:Pool-Name}' AND expiry_time < 'now'::timestamp(0) \
  ORDER BY (username <> '%{SQL-User-Name}'), (callingstationid <> '%{Calling-Station-Id}'), expiry_time \
  LIMIT 1 \
  FOR UPDATE"

 ## If you prefer to allocate a random IP address every time, use this query instead
 #allocate-find = "SELECT framedipaddress FROM ${ippool_table} \
 # WHERE pool_name = '%P' AND expiry_time < 'now'::timestamp(0) \
 # ORDER BY RANDOM() \
 # LIMIT 1 \
 # FOR UPDATE"


 ## If an IP could not be allocated, check to see if the pool exists or not
 ## This allows the module to differentiate between a full pool and no pool
 ## Note: If you are not running redundant pool modules this query may be commented
 ## out to save running this query every time an ip is not allocated.
 pool-check = "SELECT id FROM ${ippool_table} WHERE pool_name='%{control:Pool-Name}' LIMIT 1"

 
 allocate-update = "UPDATE ${ippool_table} \
  SET nasipaddress = '%{NAS-IP-Address}', pool_key = '${pool-key}', \
  callingstationid = '%{Calling-Station-Id}', username = '%{SQL-User-Name}', \
  expiry_time = 'now'::timestamp(0) + '${lease-duration} second'::interval \
  WHERE framedipaddress = '%I'"


 ## This series of queries frees an IP number when an accounting
 ## START record arrives
 start-update = "UPDATE ${ippool_table} \
  SET expiry_time = 'now'::timestamp(0) + '${lease-duration} second'::interval \
  WHERE nasipaddress = '%{NAS-IP-Address}' AND  pool_key = '${pool-key}'"

 ## This series of queries frees an IP number when an accounting
 ## STOP record arrives
 stop-clear = "UPDATE ${ippool_table} \
  SET nasipaddress = '', pool_key = 0, callingstationid = '', \
  expiry_time = 'now'::timestamp(0) - '1 second'::interval \
  WHERE nasipaddress = '%{Nas-IP-Address}' AND pool_key = '${pool-key}' AND username = '%{SQL-User-Name}' \
  AND callingstationid = '%{Calling-Station-Id}' AND framedipaddress = '%{Framed-IP-Address}'"



 ## This series of queries frees an IP number when an accounting
 ## ALIVE record arrives
 alive-update = "UPDATE ${ippool_table} \
  SET expiry_time = 'now'::timestamp(0) + '${lease-duration} seconds'::interval \
  WHERE nasipaddress = '%{Nas-IP-Address}' AND pool_key = '${pool-key}' AND username = '%{SQL-User-Name}' \
  AND callingstationid = '%{Calling-Station-Id}' AND framedipaddress = '%{Framed-IP-Address}'"


 ## This series of queries frees the IP numbers allocate to a
 ## NAS when an accounting ON record arrives
 on-clear = "UPDATE ${ippool_table} \
  SET nasipaddress = '', pool_key = 0, callingstationid = '', \
  expiry_time = 'now'::timestamp(0) - '1 second'::interval \
  WHERE nasipaddress = '%{Nas-IP-Address}' AND username = '%{SQL-User-Name}' \
  AND callingstationid = '%{Calling-Station-Id}' AND framedipaddress = '%{Framed-IP-Address}'"

 ## This series of queries frees the IP numbers allocate to a
 ## NAS when an accounting OFF record arrives
 off-clear = "UPDATE ${ippool_table} \
  SET nasipaddress = '', pool_key = 0, callingstationid = '', \
  expiry_time = 'now'::timestamp(0) - '1 second'::interval \
  WHERE nasipaddress = '%{Nas-IP-Address}' AND username = '%{SQL-User-Name}' \
  AND callingstationid = '%{Calling-Station-Id}' AND framedipaddress = '%{Framed-IP-Address}'"

