##
## radiusd.conf	-- FreeRADIUS server configuration file.
##
##	http://www.freeradius.org/
##

#
#  	The location of other config files and
#  	logfiles are declared in this file
#
#  	Also general configuration for modules can be done
#  	in this file, it is exported through the API to
#  	modules that ask for it.
#

# Stuff from autoconf
prefix = @prefix@
exec_prefix = @exec_prefix@
sysconfdir = @sysconfdir@
localstatedir = @localstatedir@
sbindir = @sbindir@
logdir = @logdir@
libdir = @libdir@
raddbdir = @raddbdir@
radacctdir = @radacctdir@

#
#  Location of config and logfiles.
#
confdir    = ${raddbdir}

run_dir    = ${localstatedir}/run

#
#  pidfile: Where to place the PID of the RADIUS server.
#
#  The server may be signalled while it's running by using this
#  file.
#
#  e.g.:  kill -HUP `cat /var/run/radiusd.pid`
#
pidfile    = ${run_dir}/radiusd.pid

#
#  max_request_time: The maximum time (in seconds) to handle a request.
#
#  Requests which take more time to process than this are killed, and
#  a REJECT message is returned.
#
max_request_time	= 30

#
#  cleanup_delay: The time to wait (in seconds) before cleaning up
#  a reply which was already sent to the NAS.  If it is set too low,
#  then duplicate requests from the NAS MAY NOT be detected,
#  and will instead be handled as seperate requests.
#
cleanup_delay		= 5

#
#  max_requests: The maximum number of requests which the server keeps
#  track of.  This should be 256 multiplied by the number of clients.
#  e.g. With 4 clients, this number should be 1024.
#
#  If this number is too low, then when the server becomes busy,
#  it will not respond to any new requests, until the 'cleanup_delay'
#  time has passed, and it has removed the old requests.
#
#  If this number is set too high, then the server will use a bit more
#  memory for no real benefit.
#
#  If you aren't sure what it should be set to, it's better to set it
#  too high than too low.  Setting it to 1000 per client is probably
#  the highest it should be.
#
max_requests		= 1024

#
#  bind_address:  Make the server listen on a particular IP address, and
#  send replies out from that address.  This directive is most useful
#  for machines with multiple IP addresses on one interface.
#
#  It can either contain "*", or an IP address, or a fully qualified
#  Internet domain name.  The default is "*"
#
bind_address            = *

#
#  port: Allows you to bind FreeRADIUS to a specific port.
#
#  The default port that most NAS boxes use is 1645, which is historical.
#  RFC 2138 defines 1812 to be the new port.  Many new servers and
#  NAS boxes use 1812, which can create interoperability problems.
#
#  The port is defined here to be 0 so that the server will pick up
#  the machine's local configuration for the radius port, as defined
#  in /etc/services.
#
#  If you want to use the default RADIUS port as defined on your server,
#  (usually through 'grep radius /etc/services') set this to 0 (zero).
#
#  A port given on the command-line via '-p' over-rides this one.
#
port = 0

#
#  Which program to execute check doing concurrency checks.
#
checkrad   = ${sbindir}/checkrad

#
#  hostname_lookups: Log the names of clients or just their IP addresses
#  e.g., www.freeradius.org (on) or 206.47.27.232 (off).
#  The default is off because it'd be overall better for the net if people
#  had to knowingly turn this feature on, since enabling it means that
#  each client request will result in AT LEAST one lookup request to the
#  nameserver.
#
#  Turning hostname lookups off also means that the server won't block
#  for 30 seconds, if it sees an IP address which has no name associated
#  with it.
#
# allowed values: {no, yes}
#
hostname_lookups	= no

#
#  Core dumps are a bad thing.  This should only be set to 'yes'
#  if you're debugging a problem with the server.
#
# allowed values: {no, yes}
#
allow_core_dumps	= no

#
#  Log the full User-Name attribute, as it was found in the request.
#
# allowed values: {no, yes}
#
log_stripped_names	= no

#
#  Log authentication requests to the log file.
#
# allowed values: {no, yes}
#
log_auth	= no

#
#  Log passwords with the authentication requests.
#
# allowed values: {no, yes}
#
log_auth_pass	= no

#
#  proxy_requests: Turns proxying of RADIUS requests on or off.
#
#  The server has proxying turned on by default.  If your system is NOT
#  set up to proxy requests to another server, then you can turn proxying
#  off here.  This will save a small amount of resources on the server.
#
#  If you have proxying turned off, and your configuration files say
#  to proxy a request, then an error message will be logged.
#
# allowed values: {no, yes}
#
proxy_requests	= yes

#######################################################################
#
#  SNMP configuration
#
#  NOTE: This part will only work if your radiusd is compiled with SNMP
#  support.
#
#  smux_password: Password used for SMUX registration.
#
#  Specifies password used when connecting to the SNMP master agent.
#  This must match the password as configured on the agent. The OID
#  used to register the radius subagent is 1.3.6.1.4.1.3317.1.3.1.
#  A sample entry for the ucd-snmp deamon looks like this:
#
#  smuxpeer .1.3.6.1.4.1.3317.1.3.1 verysecret
#
#  A sample entry for AIX 4.3 is:
#
#  smux 1.3.6.1.4.1.3317.1.3.1 verysecret
#
#  The default password is an empty password.
#
#smux_password = verysecret
#
#  snmp_write_access:
#
#  Controls if write access to the radiusd via SNMP is enabled or not.
#  Set this value to yes, if you want to be able to reload radiusd from
#  your network management station.
#
#  For this to work, you also have to make sure that your master agent
#  is configured to allow SNMP set requests. For security reasons, this
#  setting defaults to no.
#
# allowed values: {no, yes}
#
#snmp_write_access = no

#######################################################################
#
#  Proxy server configuration
#
#  This entry controls the servers behaviour towards ALL other servers
#  to which it sends proxy requests.
#
proxy server {

#
#  If the NAS re-sends the request to us, we can immediately re-send
#  the proxy request to the end server.  To do so, use 'yes' here.
#
#  If this is set to 'no', then we send the retries on our own schedule,
#  and ignore any duplicate NAS requests.
#
#  If you want to have the server send proxy retries ONLY when the NAS
#  sends it's retries to the server, then set this to 'yes', and
#  set the other proxy configuration parameters to 0 (zero).
#
# allowed values: {no, yes}
#
	synchronous = no

#
#  After sending a proxied request to the end server, we wait
#  'retry_delay' seconds for the response.  If we do not receive a response
#  from the end server within that time, then the proxy request is sent
#  again to the end server.  We then wait another for another retry_delay.
#
#  If this timeout is set too high, then the NAS *may* give up on the
#  request before we send a reply back to it.  Most NAS boxes will give up
#  on requests within 30 seconds.
#
#  If this timeout is set too low, then the end server may not have time
#  to finish processing the request, before it receives the retry.  Many
#  radius servers can take 2-3 seconds to process a request.
#
	retry_delay = 5

#
#  The number of times we send retry packets to the end server.
#  If we send 'retry_count' packets without receiving a response,
#  then we give up on that server, and return a rejection
#  message to the NAS.
#
	retry_count = 3
}

#######################################################################
#
#  Thread pool configuration.
#
#  The thread pool is a long-lived group of threads which
#  take turns (round-robin) handling any incoming requests.
#
#
#  You probably want to have a few spare threads around,
#  so that high-load situations can be handled immediately.  If you
#  don't have any spare threads, then the request handling will
#  be delayed while a new thread is created, and added to the pool.
#
#  You probably don't want too many spare threads around,
#  otherwise they'll be sitting there taking up resources, and
#  not doing anything productive.
#
#  The numbers given below should be adequate for most situations.
#
#
thread pool {
#
#  Number of servers to start initially --- should be a reasonable ballpark
#  figure.
#
	start_servers     = 5

#
#  Limit on the total number of servers running.
#
#  If this limit is ever reached, clients will be LOCKED OUT, so it
#  should NOT BE SET TOO LOW.  It is intended mainly as a brake to
#  keep a runaway server from taking the system with it as it spirals
#  down...
#
	max_servers	  = 32

#
#  Server-pool size regulation.  Rather than making you guess how many
#  servers you need, FreeRADIUS dynamically adapts to the load it
#  sees --- that is, it tries to maintain enough servers to
#  handle the current load, plus a few spare servers to handle transient
#  load spikes.
#
#  It does this by periodically checking how many servers are waiting
#  for a request.  If there are fewer than min_spare_servers, it creates
#  a new spare.  If there are more than max_spare_servers, some of the
#  spares die off.  The default values are probably OK for most sites.
#
	min_spare_servers = 3
	max_spare_servers = 10

#
#  There may be memory leaks or resource allocation problems with
#  the server.  If so, set this value to 300 or so, so that the
#  resources will be cleaned up periodically.
#
#  This should only be necessary if there are serious bugs in the
#  server which have not yet been fixed.
#
#  '0' is a special value meaning 'infinity', or 'the servers never exit'
#
	max_requests_per_server = 0
}

#######################################################################
#
#  Definition of a NAS or a client.
#
#  The information given here is in ADDITION to the 'clients' file.
#
#  If this is defined as "client foo" then the hostname/ipaddr "foo"
#  will be looked up according to the source IP address of the radius
#  rqeuest packet, and the secret here will be used to check the
#  integrety of the request.
#
#  If this is defined as "nas foo" then foo will be looked up first
#  as the NAS-IP-Address in the radius request, then as the NAS-Ident
#  in the radius request.
#
#  Normally you'd use "client" unless the request came in through a
#  proxy server and you want to define a short name for the NAS
#  for logging purposes, or you want to do a "checkrad" back to the
#  original NAS and not to the proxy radius server!
#
#  The "shortname" can be used for logging, and the "vendor",
#  "type", "login" and "password" fields are mainly used for checkrad.
#

client 127.0.0.1 {
	secret		= testing123
	shortname	= localhost
}

#client some.host.org {
#	secret		= testing123
#	shortname	= localhost
#}


client 10.10.10.10 {
	# secret and password are mapped through the "secrets" file.
	secret      = testing123
	shortname   = liv1
	vendor      = livingston
	# Type should extend to the line type, because of the "hole".
	#Line#/T S Port  SNMP Port
	#-------------------------
	#1 PRI   0-22    1-23
	#2 PRI   24-46   25-47
	#1 CT1   0-23    1-24
	#2 CT1   24-47   25-48
	#1 E1    0-28    1-29
	#2 E1    30-58   31-59
	#And C0 is 96 in Radius.
	type        = pm3-eur # pm3-i23 pm3-ct24 pm3-i30
	login       = !root
	password    = someadminpas
}

#######################################################################
#
#  Configuration for the proxy module.
#
#  The information given here is in ADDITION to the 'realms' file.
#
#realm isp2.com {
#	type        = radius
#	authhost    = radius.isp2.com:1645
#	accthost    = radius.isp2.com:1646
#	secret      = TheirKey
#	nostrip
#	utmpfile   += /var/log/radutmp.isp2
#	wtmpfile   += /var/log/radwtmp.isp2
#	detailfile += /var/log/radacct/isp2/detail
#}

#realm company.com {
#	type		= radius
#	authhost	= radius.company.com:1600
#	accthost	= radius.company.com:1601
#	secret		= testing123
#}

#realm bla.com {
#	type		= radius
#	authhost	= LOCAL
#	accthost	= LOCAL
#	secret		= testing123
#}

#realm myfakerealm {
#      type            = radius
#      authhost        = radius.company.com:1600
#      accthost        = radius.company.com:1601
#      secret          = testing123
#      notsuffix
#}


modules {
	pam {
		# No config options for this yet
	}
	unix {
		#
		#  Cache /etc/passwd, /etc/shadow, and /etc/group
		#
		#  The default is to NOT cache them.  However, caching them can
		#  speed up system authentications by a substantial amount.
		#
		# allowed values: {no, yes}
		cache		= no

		#
		#  Define the locations of the normal passwd, shadow, and
		#  group files.
		#
		#  'shadow' is commented out by default, because not all
		#  systems have shadow passwords.
		#
		passwd		= /etc/passwd
		#	shadow		= /etc/shadow
		group		= /etc/group
	}

# Uncomment this if you want to use ldap (Auth-Type = LDAP)
# Also uncomment it in the authenticate{} block below
#	ldap {
#		server   = localhost
#		login    = "cn=admin,o=My Org,c=US"
#		password = mypass
#		basedn   = "o=My Org,c=US"
#		filter   = "(uid=%u)"
#	}

	realm {
		# No config options for this yet
	}
	preprocess {
		# No config options for this yet
	}
	files {
		usersfile = ${confdir}/users
		acctusersfile = ${confdir}/acct_users
		detailperm = 0600

		#
		#  If you want to use the old Cistron 'users' file
		#  with FreeRADIUS, you should change the next line
		#  to 'compat = cistron'.  You can the copy your 'users'
		#  file from Cistron.
		#
		compat = no
	}

	# This module will add a (probably) unique session id 
	# to an accounting packet based on the attributes listed
	# below found in the packet.  see doc/README.rlm_acct_unique
	acct_unique {
		key = "User-Name, Acct-Session-Id, NAS-IP-Address, NAS-Port-Id"
	}


#
#  Configuration for the SQL module.
#
	sql {
	
		# Connect info
		server		= "localhost"
		login		= "root"
		password	= "rootpass"
		
		# Database table configuration
		radius_db	= "radius"
		acct_table	= "radacct"
		
		authcheck_table = "radcheck"
		authreply_table = "radreply"
		
		groupcheck_table = "radgroupcheck"
		groupreply_table = "radgroupreply"
		
		usergroup_table	= "usergroup"
		
		realms_table 	= "realms"
		realmgroup_table = "realmgroup"
		
		# Check case on usernames
		sensitiveusername = no
	
		# Remove stale session if checkrad does not see a double login
		deletestalesessions = yes
	
		# Print all SQL statements when in debug mode (-x)
		sqltrace	= no
	}

#
#  A second instance of the same module, with the name "sql2" to identify it
#
	sql sql2 {
	
		# Connect info
		server		= "myothersever"
		login		= "root"
		password	= "rootpass"
		
		# Database table configuration
		radius_db	= "radius"
		acct_table	= "radacct"
		
		authcheck_table = "radcheck"
		authreply_table = "radreply"
		
		groupcheck_table = "radgroupcheck"
		groupreply_table = "radgroupreply"
		
		usergroup_table	= "usergroup"
		
		realms_table 	= "realms"
		realmgroup_table = "realmgroup"
		
		# Check case on usernames
		sensitiveusername = no
	
		# Remove stale session if checkrad does not see a double login
		deletestalesessions = yes
	
		# Print all SQL statements when in debug mode (-x)
		sqltrace	= no
	}

#######################################################################
#
#	Configuration for the example module.  Uncommenting it will cause it
#	to get loaded and initialized, but should have no real effect as long
#	it is not referencened in one of the autz/auth/preacct/acct sections
#
       example {
       #
       #  Boolean variable.
       #
       # allowed values: {no, yes}
       #
               boolean		= yes

       #
       #  An integer, of any value.
       #
               integer		= 16

       #
       #  A string.
       #
               string		= "This is an example configuration string"

       #
       # An IP address, either in dotted quad (1.2.3.4) or hostname
       # (example.com)
       #
               ipaddr		= 127.0.0.1

       #
       # A subsection
       #
               mysubsection {
                       anotherinteger = 1000
       #
       # They nest
       #
                       deeply nested {
                               string = "This is a different string"
                       }
               }
       }
}

# Authentication types, Auth-Type = System and PAM for now.
authenticate {
	pam
	unix
# By grouping modules together in an authtype block, that authtype will be
# tried on each module in sequence until one returns REJECT or OK. This
# allows authentication failover if the first SQL server has crashed, for
# example.
#       authtype SQL {
#       	sql
#       	sql2
#       }
# Uncomment this if you want to use ldap (Auth-Type = LDAP)
#	ldap
}

# Authorization. First preprocess (hints and huntgroups files),
# then realms, and finally look in the "users" file.
# Make *sure* that 'preprocess' comes before 'realm' if you 
# need to setup hints for the remote radius server
authorize {
	preprocess
	realm
	files
}

# Pre-accounting. Look for proxy realm, first with the @suffix rule, then the
# acct_users file, then preprocess (hints file).
preacct {
	realm
	files
	preprocess
}

# Accounting. Log to detail file, and to the radwtmp file.
accounting {
	#acct_unique
	files
	unix
}
