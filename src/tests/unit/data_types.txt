#
#  Parse / print data types
#
value uint32 0
match 0

value ipaddr 127.0.0.1
match 127.0.0.1

#  And canonicalized
value ipaddr 127.0.0.001
match 127.0.0.1

#
#  Time deltas can have qualifiers, but they're always printed
#  as seconds.
#
#  Unless the attribute (which we don't have here) has a scale defined
#
value time_delta 1
match 1

value time_delta 2.4
match 2.4

value time_delta 1ms
match 0.001

value time_delta 1us
match 0.000001

value time_delta 1.5us
match 0.0000015

value time_delta 1ns
match 0.000000001

value time_delta 1:30
match 90

value uint8 256
match Value 256 is invalid for type uint8 (must be in range 0...255)

value uint8 -128
match Invalid negative value "-128" for unsigned integer

value int8 128
match Value 128 is invalid for type int8 (must be in range -128...127)

value int8 -128
match -128

value int8 -130
match Value -130 is invalid for type int8 (must be in range -128...127)

value date Jan  1 1970 12:00:00 UTC
match Jan  1 1970 12:00:00 UTC

#
#  10 days in
#
value date 864000
match Jan 11 1970 00:00:00 UTC

# 100 days
value date 8640000
match Apr 11 1970 00:00:00 UTC

# 1,000 days
value date 86400000
match Sep 27 1972 00:00:00 UTC

# 10,000 days
value date 864000000
match May 19 1997 00:00:00 UTC

#
#  Input can be whatever.  But for the tests, output is UTC.
#
#  Note that this test is wrong, because the HH:MM are the
#  same, even though they are in different time zones.
#  Our parse function ignores time zones, which is bad.
#
value date Aug 21 2019 07:43:03 EDT
match Aug 21 2019 07:43:03 UTC

#
#  Can't yet test this as the parse / print / parse / cmp
#  functions don't yet allow for choosing ISO8601 vs the
#  traditional FreeRADIUS time.
#
#date 2019-08-21T07:40:31-04:00
#data foo

#
#  DNS labels WITHOUT compression
#
encode-dns-label foo.com
match 03 66 6f 6f 03 63 6f 6d 00

encode-dns-label foo.com,b.ca
match 03 66 6f 6f 03 63 6f 6d 00 01 62 02 63 61 00

count
match 46
