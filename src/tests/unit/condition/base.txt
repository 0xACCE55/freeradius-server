#
#  Tests for parsing conditional expressions.
#
#  $Id$
#

proto-dictionary radius
tmpl-rules allow_unresolved=yes allow_unknown=yes

condition &request.User-Name == &reply.User-Name
match &request.User-Name == &reply.User-Name

# All IP address literals should be parsed as prefixes
condition ("foo\
match ERROR offset 2: Unterminated string

condition ("foo
match ERROR offset 2: Unterminated string

condition ()
match ERROR offset 2: No operand found.  Expected &ref, literal, 'quoted literal', "%{expansion}", or enum value

condition (!)
match ERROR offset 3: No operand found.  Expected &ref, literal, 'quoted literal', "%{expansion}", or enum value


condition (|| b)
match ERROR offset 2: No operand found.  Expected &ref, literal, 'quoted literal', "%{expansion}", or enum value

condition ((ok || handled) foo)
match ERROR offset 18: Unexpected text after condition

# escapes in names are illegal
condition (ok\ foo || handled)
match ERROR offset 4: Unexpected text after enum value.  Expected operator

condition (Service-Type == 000-111)
match ERROR offset 18: enum values must contain at least one alpha character

condition (ok FOO handled)
match ERROR offset 5: Invalid operator

condition (ok !x handled)
match ERROR offset 5: Invalid operator

condition (ok =x handled)
match ERROR offset 5: Invalid operator

#
# Re-enable when we have proper bareword xlat tokenization
#
#condition (ok == handled"foo")
#match ERROR offset 14 Unexpected text after condition

# And now we have a bunch of VALID conditions we want to parse.

# sillyness is OK, but cleaned up.
condition ((((((ok))))))
match ok

#
#  Extra braces get squashed
#
condition (&request.User-Name == &request.User-Password)
match &request.User-Name == &request.User-Password

condition (!ok)
match !ok

condition !(ok)
match !ok

condition !!ok
match ERROR offset 2: Double negation is invalid

condition !(!ok)
match ok

#
#  These next two are identical after normalization
#
condition (&request.User-Name == &request.User-Password || &request.Filter-Id == &request.Reply-Message)
match &request.User-Name == &request.User-Password || &request.Filter-Id == &request.Reply-Message

condition ((&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message))
match (&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message)

condition (!(&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message))
match !(&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message)

#  different from the previous ones.
condition (!((&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message)))
match !((&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message))

condition (!(&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message))
match !(&request.User-Name == &request.User-Password) || (&request.Filter-Id == &request.Reply-Message)

condition ((a == b) || (c == d)))
match ERROR offset 23: Unexpected closing brace

condition (handled && (&request.Packet-Type == Access-Challenge))
match  handled && (&request.Packet-Type == Access-Challenge)

# This is OK, without the braces
condition handled && &request.Packet-Type == Access-Challenge
match handled && &request.Packet-Type == Access-Challenge

# and this, though it's not a good idea.
condition handled &&&request.Packet-Type == Access-Challenge
match handled && &request.Packet-Type == Access-Challenge

condition &reply == &request
match ERROR offset 1: Nesting types such as groups or TLVs cannot be compared

condition &reply == "hello"
match ERROR offset 1: Nesting types such as groups or TLVs cannot be compared

condition "hello" == &reply
match ERROR offset 12: Nesting types such as groups or TLVs cannot be compared


#
#  Convert != to !(COND) for normal checks
#
condition &request.User-Name == &request.User-Password
match &request.User-Name == &request.User-Password

condition &request.User-Name != &request.User-Password
match !&request.User-Name == &request.User-Password

condition !&request.User-Name != &request.User-Password
match &request.User-Name == &request.User-Password

condition <ipv6addr>::1
match ERROR offset 1: Invalid cast from ipv6addr to bool.  Unsupported

condition <ipaddr>&request.Filter-Id == &request.Framed-IP-Address
match <ipaddr>&request.Filter-Id == &request.Framed-IP-Address

condition <ipaddr>&request.Filter-Id == &request.Framed-IP-Address
match <ipaddr>&request.Filter-Id == &request.Framed-IP-Address

#
#  We can automatically promote things as needed.  But if the
#  user forces incompatible types, then that's an error.
#
condition <ipaddr>&request.Filter-Id == <blerg>&request.Framed-IP-Address
match ERROR offset 32: Unknown data type

condition <blerg>&request.Filter-Id == "foo"
match ERROR offset 2: Unknown data type

#
#  Normalize things
#
condition <ipaddr>127.0.0.1 < &request.Framed-IP-Address
match &request.Framed-IP-Address > 127.0.0.1

# =* and !* are only for attrs / lists
condition "foo" !* bar
match ERROR offset 7: Invalid operator !*

condition "foo" =* bar
match ERROR offset 7: Invalid operator =*

# existence checks don't need the RHS
condition &request.User-Name =* bar
match ERROR offset 20: Invalid operator =*

condition &request.User-Name !* bar
match ERROR offset 20: Invalid operator !*

condition !&request.User-Name =* bar
match ERROR offset 21: Invalid operator =*

condition !&request.User-Name !* bar
match ERROR offset 21: Invalid operator !*

# redundant casts get squashed
condition <ipaddr>&request.Framed-IP-Address == 127.0.0.1
match &request.Framed-IP-Address == 127.0.0.1

condition <cidr>&request.Framed-IP-Address <= 192.168.0.0/16
match <ipv4prefix>&request.Framed-IP-Address <= 192.168.0.0/16

# All IP address literals should be parsed as prefixes
condition &request.Framed-IP-Address <= 192.168.0.0/16
match <ipv4prefix>&request.Framed-IP-Address <= 192.168.0.0/16

# string attributes must be string
condition &request.User-Name == "bob"
match &request.User-Name == "bob"

condition &request.User-Name == `bob`
match &request.User-Name == `bob`

condition &request.User-Name == 'bob'
match &request.User-Name == 'bob'

condition &request.User-Name == bob
match &request.User-Name == 'bob'

# Integer (etc.) types must be "bare"
condition &Session-Timeout == 10
match &request.Session-Timeout == 10

# Automatic type inference means this is fine
condition &Session-Timeout == '10'
match &request.Session-Timeout == 10

# Except for dates, which can be humanly readable!
# This one is be an expansion, so it's left as-is.
condition &request.Event-Timestamp == "January 1, 2012 %{blah}"
match &request.Event-Timestamp == "January 1, 2012 %{blah}"

# This one is NOT an expansion, so it's parsed into normal form
condition &request.Event-Timestamp == 'January 1, 2012'
#data &request.Event-Timestamp == 'Jan  1 2012 00:00:00 EST'

# literals are parsed when the conditions are parsed
condition <integer>X == 1
match ERROR offset 10: Failed parsing string as type 'uint32'

condition &NAS-Port == X
match ERROR offset 14: Failed parsing string as type 'uint32'

#
#  The RHS is a static string, so this gets mashed to a literal,
#  and then statically evaluated.
#
condition <ipaddr>127.0.0.1 == "127.0.0.1"
match true

condition <ipaddr>127.0.0.1 == "%{md4: 127.0.0.1}"
match 127.0.0.1 == "%{md4: 127.0.0.1}"

#
#  Bare %{...} is allowed.
#
condition <ipaddr>127.0.0.1 == %{md4:127.0.0.1}
match 127.0.0.1 == %{md4:127.0.0.1}

condition <ipaddr>127.0.0.1 == %{md4: SELECT user FROM table WHERE user='%{request.User-Name}'}
match 127.0.0.1 == %{md4: SELECT user FROM table WHERE user='%{request.User-Name}'}

condition <ether> 00:11:22:33:44:55 == "00:11:22:33:44:55"
match true

condition <ether>00:11:22:33:44:55 == "%{md4:00:11:22:33:44:55}"
match 00:11:22:33:44:55 == "%{md4:00:11:22:33:44:55}"

condition <ether> 00:XX:22:33:44:55 == 00:11:22:33:44:55
match ERROR offset 12: Missing separator, expected ':'

#
#  Tests for boolean data types.
#
condition true
match true

condition 1
match true

condition false
match false

condition 0
match false

condition true && (&request.User-Name == "bob")
match &request.User-Name == "bob"

condition false && (&request.User-Name == "bob")
match false

condition false || (&request.User-Name == "bob")
match &request.User-Name == "bob"

condition true || (&request.User-Name == "bob")
match true

#
#  Both sides static data with a cast: evaluate at parse time.
#
condition <integer>20 < 100
match true

#
#  Both sides literal: evaluate at parse time
#
condition ('foo' == 'bar')
match false

condition ('foo' < 'bar')
match false

condition ('foo' > 'bar')
match true

condition ('foo' == 'foo')
match true

condition ("foo" == "%{md4: foo}")
match "foo" == "%{md4: foo}"

condition ("foo bar" == "%{md4: foo}")
match "foo bar" == "%{md4: foo}"

condition ("foo" == "bar")
match false

condition ("foo" == 'bar')
match false

#
#  The RHS gets parsed as a VPT_TYPE_DATA, which is
#  a double-quoted string.  Except that there's no '%'
#  in it, so it reverts back to a literal.
#
condition (&request.User-Name == "bob")
match &request.User-Name == "bob"

condition (&request.User-Name == "%{md4: blah}")
match &request.User-Name == "%{md4: blah}"

condition <ipaddr>127.0.0.1 == 2130706433
match true

# /32 suffix should be trimmed for this type
condition <ipaddr>127.0.0.1/32 == 127.0.0.1
match true

condition <ipaddr>127.0.0.1/327 == 127.0.0.1
match ERROR offset 9: Invalid IPv4 mask length "/327".  Should be between 0-32

condition <ipaddr>127.0.0.1/32 == 127.0.0.1
match true

condition (/foo/)
match ERROR offset 2: Unexpected regular expression

#
#  Tests for (FOO).
#
condition (1)
match true

condition (0)
match false

condition (true)
match true

condition (false)
match false

condition ('')
match false

condition ("")
match false

#
#  Integers are true, as are non-zero strings
#
condition (4)
match true

condition ('a')
match true

condition (a)
match ERROR offset 2: Expected a module return code

#
#  Module return codes are OK
#
condition (ok)
match ok

condition (handled)
match handled

condition (fail)
match fail

condition ("a")
match true

condition (`a`)
match `a`

condition (&User-name)
match &request.User-Name

#
#  Forbidden data types in cast
#
condition (<vsa>"foo" == &request.User-Name)
match ERROR offset 3: Forbidden data type 'vsa' in cast

#
#  If the LHS is a cast to a type, and the RHS is an attribute
#  of the same type, then re-write it so that the attribute
#  is on the LHS of the condition.
#
condition <string>"foo" == &request.User-Name
match &request.User-Name == "foo"

# This used to be expr, but expr isn't a builtin, so it failed...
condition <integer>"%{md4: 1 + 1}" < &request.NAS-Port
match &request.NAS-Port > <uint32>"%{md4: 1 + 1}"

#
#  The string gets parsed as an IP address.
#
condition &request.Filter-Id == &request.Framed-IP-Address
match <ipaddr>&request.Filter-Id == &request.Framed-IP-Address

condition <ipaddr>127.0.0.1 == &request.Filter-Id
match <ipaddr>&request.Filter-Id == 127.0.0.1

condition &request.Tmp-uint64-0 == &request.Foo-Stuff-Bar
match &request.Tmp-uint64-0 == &request.Foo-Stuff-Bar

condition &request.Tmp-uint64-0 == &reply.Foo-Stuff-Bar
match &request.Tmp-uint64-0 == &reply.Foo-Stuff-Bar

#
#  Casting attributes of different size
#
condition <ipaddr>&request.Tmp-uint64-0 == &request.Framed-IP-Address
match ERROR offset 9: Cannot cast type 'uint64' to 'ipaddr'

#
#  LHS is a prefix, which _might_ be castable to an address
#  if the prefix is /32.  We don't know enough at compile time,
#  so this may be a run-time failure.
#
condition <ipaddr>&request.PMIP6-Home-IPv4-HoA == &request.Framed-IP-Address
match <ipaddr>&request.PMIP6-Home-IPv4-HoA == &request.Framed-IP-Address

# but these are allowed
condition <ether>&request.Tmp-uint64-0 == "%{module: foo}"
match <ether>&request.Tmp-uint64-0 == "%{module: foo}"

condition <ipaddr>&request.Filter-Id == &request.Framed-IP-Address
match <ipaddr>&request.Filter-Id == &request.Framed-IP-Address

condition <ipaddr>&request.Class == &request.Framed-IP-Address
match <ipaddr>&request.Class == &request.Framed-IP-Address

#
#  zero offset into arrays get parsed and ignored
#
condition &request.User-Name[0] == "bob"
match &request.User-Name[0] == "bob"

condition &request.User-Name[1] == "bob"
match &request.User-Name[1] == "bob"

condition &request.User-Name[n] == "bob"
match &request.User-Name[n] == "bob"

#
#  This is allowed for pass2-fixups.  Foo-Bar MAY be an attribute.
#  If so allow it so that pass2 can fix it up.  Until then,
#  it's an unknown attribute
#
condition &request.Foo-Bar
match &request.Foo-Bar

#  Same types are optimized
#
#  FIXME: the tests don't currently run the "pass2" checks.
#  This test should really be:
#
#	data &request.Acct-Input-Octets > &request.Session-Timeout
#
condition &request.Acct-Input-Octets > "%{request.Session-Timeout}"
match &request.Acct-Input-Octets > "%{request.Session-Timeout}"

#  Separate types aren't optimized
condition &request.Acct-Input-Octets-64 > "%{request.Session-Timeout}"
match &request.Acct-Input-Octets-64 > "%{request.Session-Timeout}"

#
#  Parse OIDs into known attributes, where possible.
#
condition &26.24757.84.9.5.4 == 0x1a99
match &request.Vendor-Specific.WiMAX.Packet-Flow-Descriptor-v2.Classifier.Src-Spec.Port == 6809

#
#  This OID is known, but the data is malformed.
#  Allow it so that we can look for malformed attributes
#  in packets.
#
condition &raw.request.26.24757.84.9.5.7 == 0x1a99
match &raw.request.Vendor-Specific.WiMAX.Packet-Flow-Descriptor-v2.Classifier.Src-Spec.Assigned == 0x1a99

#  This one is really unknown
condition &request.26.24757.84.9.5.15 == 0x1a99
match &request.Vendor-Specific.WiMAX.Packet-Flow-Descriptor-v2.Classifier.Src-Spec.15 == 0x1a99

#
#  Invalid array references.
#
condition &request.User-Name[a] == 'bob'
match ERROR offset 20: Invalid array index

condition &request.User-Name == &request.Filter-Id[a]
match ERROR offset 42: Invalid array index

#
#  Bounds checks...
#
condition &request.User-Name[1001] == 'bob'
match ERROR offset 20: Invalid array index '1001' (should be between 0-1000)

condition &request.User-Name[-1] == 'bob'
match ERROR offset 20: Invalid array index '-1' (should be between 0-1000)

#
#  Sometimes the attribute/condition parser needs to fallback to bare words
#
condition request.Foo == 'request.Foo'
match true

# Bareword compared with bareword is true
condition request.Foo+Bar == request.Foo+Bar
match true

condition &request.Foo+Bar == 'request.Foo+Bar'
match ERROR offset 13: Unexpected text after attribute reference

condition 'request.Foo+d' == &request.Foo+Bar
match ERROR offset 32: Unexpected text after attribute reference

#  Attribute tags are not allowed for unknown attributes
condition &request.FooBar:0 == &request.FooBar
match ERROR offset 16: Unexpected text after attribute reference

condition &not-a-list:User-Name == &not-a-list:User-Name
match ERROR offset 12: Unexpected text after attribute reference

# . is a valid dictionary name attribute, so we can't error out in pass1
condition &request.not-a-packet.User-Name == &request.not-a-packet.User-Name
match &request.not-a-packet.User-Name == &request.not-a-packet.User-Name

#
#  The LHS is a string with ASCII 5C 30 30 30 inside of it vs the RHS which should contain ASCII 0.
#
condition ('i have scary embedded things\000 inside me' == "i have scary embedded things\000 inside me")
match false

#
#  'Unknown' attributes which are defined in the main dictionary
#  should be resolved to their real names.
condition &request.1 == 0x616263
match &request.User-Name == 'abc'

condition &request.26.11344.1 == 0x7f000001
match &request.Vendor-Specific.FreeRADIUS.Proxied-To == 127.0.0.1

#
#  Escape the backslashes correctly
#  And print them correctly
#
condition &request.User-Name == '\\'
match &request.User-Name == '\\'

condition &request.User-Name == "@|\\"
match &request.User-Name == "@|\\"

condition &request.User-Name != "foo\nbar"
match !&request.User-Name == "foo\nbar"

#
#  We infer that the LHS is a prefix and the RHS is
#  and ipaddr without requiring an explicit cast.
#
condition 192.168.0.0/16 > 192.168.1.2
match true

condition <ipv4prefix>192.168.0.0/16 > 192.168.1.2
match true

condition <ipv4prefix>&request.NAS-IP-Address == 192.168.0.0/24
match <ipv4prefix>&request.NAS-IP-Address == 192.168.0.0/24

#
#  rewrite so that the attribute is on the LHS
#  and, move the cast to the attribute, as the RHS
#  is parsed as ipv4prefix
#
condition <ipv4prefix>192.168.0.0/24 > &request.NAS-IP-Address
match <ipv4prefix>&request.NAS-IP-Address < 192.168.0.0/24

#
#  This is allowed and means "the list is not empty"
#
condition (&reply.)
match &reply.

#
#  Expansions of environment variables
#  and empty strings
#
#  @todo - disabled due to moving cf_expand_variables() from
#  cond_tokenize() to cf_file.c.  The new xlat expression parser
#  will *not* optimize this at parse time, but *will* optimize
#  this at purification time.
#
#condition ("$ENV{SOMETHING_OR_OTHER}" == '')
#match true

#
#  Attributes with a protocol namespace
#
condition &radius.User-Name == 'bob'
match &request.User-Name == 'bob'

condition !(!(0))
match false

condition (true) && (false)
match false

#
#  More short-circuit evaluations
#
condition (&request.User-Name == "bob") && (false)
match false

condition (&request.User-Name == "bob") || (true)
match true

#
#  A && (B || C) is not the same as (A && B) || C, for 0/1/1
#
#	0 && (1 || 1) = 0 && 1 == 0
#	(0 && 1) || 1 = 0 || 1 == 1
#
condition (&request.User-Name == "bob") && ((&request.User-Password == "bob") || &request.EAP-Message)
match (&request.User-Name == "bob") && ((&request.User-Password == "bob") || &request.EAP-Message)

count
match 307
