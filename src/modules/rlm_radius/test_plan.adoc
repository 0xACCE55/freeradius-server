= Manual test plan for rlm_radius

[NOTE]
====
This test plan has not been executed.  There may be errors or false assumptions
Please report any issues with the test plan itself.
Feel free to add any other useful resources such as network diagrams or commands
to introduce packet loss or setup tests hosts.
====

[NOTE]
====
Networking/socket APIs produce faults under different conditions.

sendmsg on MacOS for example, produces no indication of reachability issues, and a real
sendmmsg is only available on Linux, FreeBSD.
====

For load tests, or sending multiple packets in quick succession proto_radius_load should
be used to generate input packets and produce packet rate information.

Do not use radperf as it introduces additional latency and multiple instances are
required to achieve high packet rates (meaning accurate rate information is not available).

For sending small numbers of test packets radclient should be used.

== Test packets - Sent outbound to destination
=== Access-Request
==== PAP Access-Request

```
User-Name = "testuser"
User-Password = "supersecret"
Service-Type = Framed-User
Tunnel-Password = 0xff0B7375706572736563726574000000
Class = 0x69616D616E6F706171756576616C756569616D616E6F706171756576616C7565
```

==== CHAP Access-Request
```
User-Name = "testuser"
Chap-Password = %{chap_password:supersecret}
Service-Type = Framed-User
NAS-IP-Address = 127.0.0.1
Tunnel-Password = 0xff0B7375706572736563726574000000
Class = 0x69616D616E6F706171756576616C756569616D616E6F706171756576616C7565
```

=== Accounting-Request
```
User-Name = "testuser"
Acct-Session-ID = "0123456789"
Service-Type = Framed-User
NAS-IP-Address = 127.0.0.1
NAS-Port-ID = 0
Message-Authenticator = 0x
```

=== CoA-Request
```
User-Name = "testuser"
Acct-Session-ID = "0123456789"
Service-Type = Framed-User
NAS-IP-Address = 127.0.0.1
NAS-Port-ID = 0
Message-Authenticator = 0x
```

=== Disconnect-Message
```
User-Name = "testuser"
Acct-Session-ID = "0123456789"
Service-Type = Framed-User
NAS-IP-Address = 127.0.0.1
NAS-Port-ID = 0
Message-Authenticator = 0x
```

== 1. Replicate mode

Set `replicate = yes` to enable replicate mode.

=== 1.1 Spurious ICMP responses

Platforms:: MacOS, Linux, FreeBSD

Rationale:: We try hard to discard responses as efficiently as possible.  We do however need to ensure that
the method we use to discard replies do not result in spurious ICMP responses sent by the OS when it discards
incoming RADIUS packets.

---

* Send a <<PAP Access-Request>> - Verify that
** No ICMP messages are generated by the operating system.

=== 1.2 Base packet rate

Platforms:: MacOS, Linux, FreeBSD

Rationale:: As there is no acknowledgement required, packet rate tests, test only the ability of the rlm_radius
module to transmit packets.  On Linux and FreeBSD we'd expect an exceptionally high packet rate in this mode,
as we coalesce multiple outbound packets and send them with a single call to `sendmmsg.` For MacOS each outbound
packet requires a system call, so we expect the rate to be significantly lower.

---

* Ensure the server is running in multi-threaded mode, a non-debug build is being used, and debug messages are set
  to the minimum level.
* Configure proto_radius_load `parallel = 1024` (this matches the default coalesce size in rlm_radius).
* Configure proto_radius_load `start_pps = 10000`
* Configure proto_radius_load `duration = 5`
* Configure proto_radius_load `max_pps = 500000`
* Configure proto_radius_load `max_backlog = 4096` - This essentially controls how many packets are "in flight"
  within the server for any given period.
* Set `<transport>.max_packet_size = 128` to reduce memory consumption - This has a direct effect on the amount of
  memory pre-allocated in trunk requests.
** Use the PAP test packet.  Verify a packet rate of at least 25,000PPS on MacOS, and 50,000PPS on Linux and FreeBSD.

== 2. Proxy mode

=== 2.1 Entering and exiting zombie state

Platforms:: Any

Note:: You may need to increase `max_request_time` in radius.conf to 60 seconds for this test.

* Ensure `status_check.type` is not set.
* Set `zombie_period = 10`.
* Send a <<PAP Access-Request>>
** Verify a response is received.
* Set packet loss rate on network link to be 100%
* Send a <<PAP Access-Request>>
** Verify that after `<transport>.initial_retransmission_time` (default 2 seconds) the packet is resent.
** Verify that packets are resent at increasing intervals until `<transport>.maximum_retransmission_count`
   is reached.
** After 10 seconds, verify that the connection is marked as "inactive", and a message is emitted indicating
   that the connection has entered zombie state.
*** Verify that a new connection is opened.
*** Verify that the outstanding request is re-queued on this new connection.

=== 2.5 Memory usage under adverse conditions

Platforms:: Any

Repeat with no `status_check.type` and `status_check.type = status-server`.

* Configure a packet loss rate of 35%.
* Send <<PAP Access-Request>>s at a high rate for 30 minutes.
** Ensure memory usage stabilises within 15 minutes and does not continue to increase.

== 3. Both replicate and proxy modes

Repeat these tests for `replicate = yes` and `replicate = no`.

=== 3.1 Well formedness

Platforms:: Any

Notes:: Use radsniff or wireshark to capture sent packets for validation.
You will need to use different subrequest types to produce the different packet types.

---

* Send a <<PAP Access-Request>> - Verify that:
** Packet is well formed.
** Message-Authenticator attribute is present and correct.
* Send a <<CHAP Access-Request>> - Verify that:
** Packet is well formed.
** CHAP-Challenge is present and matches the Authentication Vector of the input packet.
** Message-Authenticator attribute is present and correct.
* Send an <<Accounting-Request>> - Verify that:
** Packet is well formed.
** No Message-Authenticator attribute is present
* Send a <<CoA-Request>>
** Packet is well formed.
** Message-Authenticator attribue is present.
* Send a <<Disconnect-Message>>
** Packet is well formed.
** Message-Authenticator attribue is present.

=== 3.2 Outbound packet buffer overrun

Platforms:: Any

Rationale:: Verify that internal logic deals correctly with packet buffer overruns.

---

* Set `<transport>.max_packet_size = 64`
* Send a <<PAP Access-Request>> - Verify that:
** An error is produced explaining why the packet can't be encoded (out of buffer space).
** The request fails (Look for trunk state transition `PENDING -> FAILED`).
** The connection is *NOT* re-established.
** The request is not re-queued and the rlm_radius returns the `fail` return code.
* Unset `<transport>.max_packet_size`

=== 3.3 SNDBUF exhaustion - single packet

Platforms:: MacOS, Linux, FreeBSD

Rationale:: Verify correct behaviour when the packet size exceeds the `SO_SNDBUF` value
for the socket. `SO_SNDBUF` on the socket should be configured to be small enough that any
outbound requests immediately fail, hopefully with an error which allows us to distinguish
between a temporary buffer exhaustion condition, and a permanent error (packet too big).

---

* set `<transport>.send_buff = 64`
* Send a <<PAP Access-Request>> - Verify that:
** An error is produced explaining why the packet can't be sent (`EMSGSIZE`). If a different
   error is produced, count this as a test fail and record the error.
** The request fails (Look for trunk state transition `PENDING -> FAILED`).
** The connection is *NOT* re-established.  This is a temporary condition, not a fatal one.
** The request is not re-queued and the rlm_radius returns the `fail` return code.
* unset `<transport>.send_buff`

=== 3.4 SNDBUF exhaustion - multiple packets

Platforms:: MacOS, Linux, FreeBSD

Rationale:: Verify correct behaviour when no mbuffs are available in the kernel to
accept new packets from userland. `SO_SNDBUF` on the socket should be configured to be large
enough to allow at least one packet to be sent but small enough to cause subsequent packets to
fail.

---

* set `<transport>.send_buff` = 128`
* Send multiple <<PAP Access-Request>>s at a high rate - Verify that:
** The first request is sent successfully.
** A subsequent request fails.  You'll likely see two failure conditions, one with an explicit
   error, and one where coalesced packets are silently re-queued.  It depends on whether the
   error occurs on the first packet being processed by sendmmsg or a subsequent one.
** Verify that for the explicit failure the error message is (`ENOBUFS`, `EWOULDBLOCK` or `EAGAIN`).
** The connection is *NOT* re-established.  This is a temporary condition, not a fatal one.
** Requests do not explicitly fail (absence of `PENDING -> FAILED` transitions).
* unset `<transport>.send_buff`

=== 3.5 EHOSTUNREACH - Unreachable host

Platforms:: MacOS, Linux, FreeBSD

---

* Configure a destination host on the same subnet as one of the DUT's interfaces.
  This host should not exist.
* Send 50 <<PAP Access-Request>>s 0.5 seconds apart (set parallel = 1 and use the delay module).
* ARP resolution failures should result in sendmmsg returning an error code `EHOSTUNREACH`
  though this may very depending on platform.
** Verify that writing fails with `EHOSTUNREACH` or other appropriate error code.
** Verify that this error results in the connection being re-established.
** Verify that requests are re-queued onto another connection or immediately fail.

=== 3.6 ENETUNREACH - Unreachable network

Platforms:: MacOS, Linux, FreeBSD

---

* Configure a destination host on the a different, unreachable subnet as one of the DUT's
  interfaces.  You may need to remove the default route for this host, or ensure that the
  upstream router sends ICMP Unreachable messages.
* Send 50 <<PAP Access-Request>>s 0.5 seconds apart (set parallel = 1 and use the delay module).
* Local routing or ICMP Unreachable messages should result in `ENETUNREACH` being returned.
** Verify that writing fails with `ENETUNREACH` or other appropriate error code.
** Verify that this error results in the connection being re-established.
** Verify that requests are re-queued onto another connection or immediately fail.

=== 3.7 ENETDOWN - Network interface down

Platforms:: MacOS, Linux, FreeBSD

---

* Configure a destination host on the same subnet as one of the DUT's interfaces.  You may
  need to remove the default route if there are multiple interfaces.
* Send 50 <<PAP Access-Request>>s 0.5 seconds apart (set parallel = 1 and use the delay module).
* As messages are being sent disable the interface the packets are being set out of.
** Verify that writing fails with `ENETDOWN` or other appropriate error code.
** Verify that this error results in the connection being re-established.
** Verify that requests are re-queued onto another connection or immediately fail.

=== 3.8 Memory usage

Platforms:: Any

* Send <<PAP Access-Request>>s at a high rate for 30 minutes.
** Record memory usage every 5 minutes.
** Ensure memory usage stabilises within 15 minutes and does not continue to increase.

